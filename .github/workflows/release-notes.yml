# Backup: Generate Release Notes from commits
# This workflow generates release notes from commits when PRs are not available.
# For PR-based releases, use GitHub's built-in "Generate release notes" button
# which uses .github/release.yml configuration.

name: Generate Release Notes (Backup)

# DISABLED - Using GitHub's built-in "Generate release notes" instead
# This workflow is kept for reference but will NOT run automatically.
# To enable: uncomment the "on:" section below and remove workflow_dispatch

# on:
#   release:
#     types: [created]

# Only allows manual trigger, prevents automatic execution
on:
  workflow_dispatch:

jobs:
  generate-release-notes:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes from Commits
        id: generate_notes
        uses: actions/github-script@v7
        with:
          script: |
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: context.payload.release.id,
            });
            
            const tagName = release.tag_name;
            const previousTag = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 2,
            });
            
            let previousTagName = '';
            if (previousTag.data.length > 1) {
              previousTagName = previousTag.data[1].name;
            }
            
            // Get commits between tags
            const { data: commits } = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: previousTagName || 'HEAD~50',
              head: tagName,
            });
            
            // Categorize commits
            const breaking = [];
            const features = [];
            const fixes = [];
            const improvements = [];
            const docs = [];
            const other = [];
            
            commits.commits.forEach(commit => {
              const message = commit.commit.message;
              const firstLine = message.split('\n')[0];
              
              if (firstLine.toLowerCase().includes('breaking') || firstLine.includes('!:')) {
                breaking.push(`- ${firstLine}`);
              } else if (firstLine.toLowerCase().startsWith('feat') || firstLine.toLowerCase().includes('feature')) {
                features.push(`- ${firstLine}`);
              } else if (firstLine.toLowerCase().startsWith('fix') || firstLine.toLowerCase().includes('bug')) {
                fixes.push(`- ${firstLine}`);
              } else if (firstLine.toLowerCase().startsWith('refactor') || firstLine.toLowerCase().includes('improve')) {
                improvements.push(`- ${firstLine}`);
              } else if (firstLine.toLowerCase().startsWith('docs') || firstLine.toLowerCase().includes('doc')) {
                docs.push(`- ${firstLine}`);
              } else if (!firstLine.toLowerCase().startsWith('chore') && !firstLine.toLowerCase().startsWith('ci') && !firstLine.toLowerCase().startsWith('build')) {
                other.push(`- ${firstLine}`);
              }
            });
            
            // Build release notes
            let releaseNotes = `## Release ${tagName}\n\n`;
            
            if (breaking.length > 0) {
              releaseNotes += `### Breaking Changes\n${breaking.join('\n')}\n\n`;
            }
            if (features.length > 0) {
              releaseNotes += `### New Features\n${features.join('\n')}\n\n`;
            }
            if (fixes.length > 0) {
              releaseNotes += `### Bug Fixes\n${fixes.join('\n')}\n\n`;
            }
            if (improvements.length > 0) {
              releaseNotes += `### Improvements\n${improvements.join('\n')}\n\n`;
            }
            if (docs.length > 0) {
              releaseNotes += `### Documentation\n${docs.join('\n')}\n\n`;
            }
            if (other.length > 0) {
              releaseNotes += `### Other Changes\n${other.join('\n')}\n\n`;
            }
            
            if (previousTagName) {
              releaseNotes += `\n**Full Changelog**: ${previousTagName}...${tagName}`;
            }
            
            // Update release
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: context.payload.release.id,
              body: releaseNotes
            });
            
            console.log('Release notes generated successfully!');

